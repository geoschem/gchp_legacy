! $Id: ESMF_Attribute.cppF90,v 1.56.2.1 2010/02/05 20:03:28 svasquez Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2010, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
#define ESMF_FILENAME "ESMF_Attribute.F90"
!==============================================================================
!
! ESMF Attribute Module
!
! (all lines between the !BOP and !EOP markers will be included in the
! automated document processing.)
!------------------------------------------------------------------------------
! one blank line for protex processing - in case all routines here are
! marked internal (BOPI/EOPI), the output file will still have contents.
!BOP

!EOP

!------------------------------------------------------------------------------
! module definition

module ESMF_AttributeMod
!
!------------------------------------------------------------------------------
! INCLUDES
#include "ESMF.h"

#define ESMF_NO_INTEGER_1_BYTE
#define ESMF_NO_INTEGER_2_BYTE

!==============================================================================
!BOPI
! !MODULE: ESMF_AttributeMod - Attribute API
!
! !DESCRIPTION:
!
! The code in this file implements the Attribute defined type
! and functions. This is an
! interface to the actual C++ Attribute class implementation
! in the ../../Infrastructure/Attribute dir.
!
! See the ESMF Developers Guide document for more details.
!
!------------------------------------------------------------------------------
! !USES:
  use ESMF_BaseMod
  use ESMF_UtilTypesMod ! ESMF utility types
  use ESMF_InitMacrosMod ! ESMF initializer macros
  use ESMF_LogErrMod ! ESMF error handling
  use ESMF_ArrayMod
  Use ESMF_ArrayBundleMod
  use ESMF_CompMod
  use ESMF_CplCompMod
  use ESMF_GridCompMod
  use ESMF_DistGridMod
  use ESMF_FieldMod
  use ESMF_FieldBundleMod
  use ESMF_GridMod
  use ESMF_StateTypesMod
  use ESMF_StateVaMod
  use ESMF_StateMod
  use ESMF_VMMod

  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private

!------------------------------------------------------------------------------
! ! ESMF_Attribute
!
!------------------------------------------------------------------------------

  type ESMF_Attribute
  sequence
    character(len=ESMF_MAXSTR) :: attr_name
    type(ESMF_DataValue) :: attr_value
  end type

!------------------------------------------------------------------------------
!
! !DESCRIPTION:
! The following routines apply to {\tt ESMF\_Array}, {\tt ESMF\_ArrayBundle},
! {\ESMF_DistGrid}, {\tt ESMF\_Field},{\tt ESMF\_FieldBundle}, {\tt ESMF\_Grid},
! and {\tt ESMF\_State}.
!
! !PUBLIC MEMBER FUNCTIONS:
!
! Classes
      public ESMF_Attribute

! Attribute methods
      public ESMF_AttributeAdd
      public ESMF_AttributeCopy
      public ESMF_AttributeRemove
      public ESMF_AttributeGet
      public ESMF_AttributeLink
      public ESMF_AttributeLinkRemove
      public ESMF_AttributeSet
      public ESMF_AttributeUpdate
      public ESMF_AttributeRead
      public ESMF_AttributeWrite

!EOPI
!------------------------------------------------------------------------------
! leave the following line as-is; it will insert the cvs ident string
! into the object file for tracking purposes.
      character(*), parameter, private :: version = &
               '$Id: ESMF_Attribute.cppF90,v 1.56.2.1 2010/02/05 20:03:28 svasquez Exp $'
!------------------------------------------------------------------------------
!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeAdd - Create Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeAdd

! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttAddPackCstm
        module procedure ESMF_ArrayAttAddPackStd
        module procedure ESMF_ArrayBundleAttAddPackCstm
        module procedure ESMF_ArrayBundleAttAddPackStd
        module procedure ESMF_CplCompAttAddPackStd
        module procedure ESMF_CplCompAttAddPackCstm
        module procedure ESMF_GridCompAttAddPackStd
        module procedure ESMF_GridCompAttAddPackCstm
        module procedure ESMF_DistGridAttAddPackCstm
        module procedure ESMF_FieldAttAddPackStd
        module procedure ESMF_FieldAttAddPackCstm
        module procedure ESMF_FieldBundleAttAddPackCstm
        module procedure ESMF_GridAttAddPackStd
        module procedure ESMF_GridAttAddPackCstm
        module procedure ESMF_StateAttAddPackStd
        module procedure ESMF_StateAttAddPackCstm

! !DESCRIPTION:
! This interface provides a single entry point for methods that create
! an Attribute package.

!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute or hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeCopy

! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_CplCompAttCopy
        module procedure ESMF_GridCompAttCopy
        module procedure ESMF_StateAttCopy

! !DESCRIPTION:
! This interface provides a single entry point for methods that copy
! an Attribute or Attribute hierarchy.

!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRemove

! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttRemove
        module procedure ESMF_ArrayBundleAttRemove
        module procedure ESMF_CplCompAttRemove
        module procedure ESMF_GridCompAttRemove
        module procedure ESMF_DistGridAttRemove
        module procedure ESMF_FieldAttRemove
        module procedure ESMF_FieldBundleAttRemove
        module procedure ESMF_GridAttRemove
        module procedure ESMF_StateAttRemove

! !DESCRIPTION:
! This interface provides a single entry point for methods that destroy
! an Attribute or Attribute package.

!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGet - Get Attributes, Attribute packages, count,
! info, and type
!
! !INTERFACE:
      interface ESMF_AttributeGet

! !PRIVATE MEMBER FUNCTIONS:
        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttGetI2 
#endif 
 module procedure ESMF_ArrayAttGetI4 
 module procedure ESMF_ArrayAttGetI8 
 module procedure ESMF_ArrayAttGetR4 
 module procedure ESMF_ArrayAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttGet1DI2 
#endif 
 module procedure ESMF_ArrayAttGet1DI4 
 module procedure ESMF_ArrayAttGet1DI8 
 module procedure ESMF_ArrayAttGet1DR4 
 module procedure ESMF_ArrayAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayAttGetLgcl
        module procedure ESMF_ArrayAttGetLgclList
        module procedure ESMF_ArrayAttGetChar
        module procedure ESMF_ArrayAttGetCharList
        module procedure ESMF_ArrayAttGetInfoByNam
        module procedure ESMF_ArrayAttGetInfoByNum
        module procedure ESMF_ArrayAttGetCount

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttGetI2 
#endif 
 module procedure ESMF_ArrayBundleAttGetI4 
 module procedure ESMF_ArrayBundleAttGetI8 
 module procedure ESMF_ArrayBundleAttGetR4 
 module procedure ESMF_ArrayBundleAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttGet1DI2 
#endif 
 module procedure ESMF_ArrayBundleAttGet1DI4 
 module procedure ESMF_ArrayBundleAttGet1DI8 
 module procedure ESMF_ArrayBundleAttGet1DR4 
 module procedure ESMF_ArrayBundleAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayBundleAttGetLgcl
        module procedure ESMF_ArrayBundleAttGetLgclList
        module procedure ESMF_ArrayBundleAttGetChar
        module procedure ESMF_ArrayBundleAttGetCharList
        module procedure ESMF_ArrayBundleAttGetInfoByNam
        module procedure ESMF_ArrayBundleAttGetInfoByNum
        module procedure ESMF_ArrayBundleAttGetCount

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttGetI2 
#endif 
 module procedure ESMF_CplCompAttGetI4 
 module procedure ESMF_CplCompAttGetI8 
 module procedure ESMF_CplCompAttGetR4 
 module procedure ESMF_CplCompAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttGet1DI2 
#endif 
 module procedure ESMF_CplCompAttGet1DI4 
 module procedure ESMF_CplCompAttGet1DI8 
 module procedure ESMF_CplCompAttGet1DR4 
 module procedure ESMF_CplCompAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_CplCompAttGetLgcl
        module procedure ESMF_CplCompAttGetLgclList
        module procedure ESMF_CplCompAttGetChar
        module procedure ESMF_CplCompAttGetCharList
        module procedure ESMF_CplCompAttGetInfoByNam
        module procedure ESMF_CplCompAttGetInfoByNum
        module procedure ESMF_CplCompAttGetCount

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttGetI2 
#endif 
 module procedure ESMF_GridCompAttGetI4 
 module procedure ESMF_GridCompAttGetI8 
 module procedure ESMF_GridCompAttGetR4 
 module procedure ESMF_GridCompAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttGet1DI2 
#endif 
 module procedure ESMF_GridCompAttGet1DI4 
 module procedure ESMF_GridCompAttGet1DI8 
 module procedure ESMF_GridCompAttGet1DR4 
 module procedure ESMF_GridCompAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridCompAttGetLgcl
        module procedure ESMF_GridCompAttGetLgclList
        module procedure ESMF_GridCompAttGetChar
        module procedure ESMF_GridCompAttGetCharList
        module procedure ESMF_GridCompAttGetInfoByNam
        module procedure ESMF_GridCompAttGetInfoByNum
        module procedure ESMF_GridCompAttGetCount

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttGetI2 
#endif 
 module procedure ESMF_DistGridAttGetI4 
 module procedure ESMF_DistGridAttGetI8 
 module procedure ESMF_DistGridAttGetR4 
 module procedure ESMF_DistGridAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttGet1DI2 
#endif 
 module procedure ESMF_DistGridAttGet1DI4 
 module procedure ESMF_DistGridAttGet1DI8 
 module procedure ESMF_DistGridAttGet1DR4 
 module procedure ESMF_DistGridAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_DistGridAttGetLgcl
        module procedure ESMF_DistGridAttGetLgclList
        module procedure ESMF_DistGridAttGetChar
        module procedure ESMF_DistGridAttGetCharList
        module procedure ESMF_DistGridAttGetInfoByNam
        module procedure ESMF_DistGridAttGetInfoByNum
        module procedure ESMF_DistGridAttGetCount

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttGetI2 
#endif 
 module procedure ESMF_FieldAttGetI4 
 module procedure ESMF_FieldAttGetI8 
 module procedure ESMF_FieldAttGetR4 
 module procedure ESMF_FieldAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttGet1DI2 
#endif 
 module procedure ESMF_FieldAttGet1DI4 
 module procedure ESMF_FieldAttGet1DI8 
 module procedure ESMF_FieldAttGet1DR4 
 module procedure ESMF_FieldAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldAttGetLgcl
        module procedure ESMF_FieldAttGetLgclList
        module procedure ESMF_FieldAttGetChar
        module procedure ESMF_FieldAttGetCharList
        module procedure ESMF_FieldAttGetInfoByNam
        module procedure ESMF_FieldAttGetInfoByNum
        module procedure ESMF_FieldAttGetCount

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttGetI2 
#endif 
 module procedure ESMF_FieldBundleAttGetI4 
 module procedure ESMF_FieldBundleAttGetI8 
 module procedure ESMF_FieldBundleAttGetR4 
 module procedure ESMF_FieldBundleAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttGet1DI2 
#endif 
 module procedure ESMF_FieldBundleAttGet1DI4 
 module procedure ESMF_FieldBundleAttGet1DI8 
 module procedure ESMF_FieldBundleAttGet1DR4 
 module procedure ESMF_FieldBundleAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldBundleAttGetLgcl
        module procedure ESMF_FieldBundleAttGetLgclList
        module procedure ESMF_FieldBundleAttGetChar
        module procedure ESMF_FieldBundleAttGetCharList
        module procedure ESMF_FieldBundleAttGetInfoByNam
        module procedure ESMF_FieldBundleAttGetInfoByNum
        module procedure ESMF_FieldBundleAttGetCount

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttGetI2 
#endif 
 module procedure ESMF_GridAttGetI4 
 module procedure ESMF_GridAttGetI8 
 module procedure ESMF_GridAttGetR4 
 module procedure ESMF_GridAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttGet1DI2 
#endif 
 module procedure ESMF_GridAttGet1DI4 
 module procedure ESMF_GridAttGet1DI8 
 module procedure ESMF_GridAttGet1DR4 
 module procedure ESMF_GridAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridAttGetLgcl
        module procedure ESMF_GridAttGetLgclList
        module procedure ESMF_GridAttGetChar
        module procedure ESMF_GridAttGetCharList
        module procedure ESMF_GridAttGetInfoByNam
        module procedure ESMF_GridAttGetInfoByNum
        module procedure ESMF_GridAttGetCount

        !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttGetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttGetI2 
#endif 
 module procedure ESMF_StateAttGetI4 
 module procedure ESMF_StateAttGetI8 
 module procedure ESMF_StateAttGetR4 
 module procedure ESMF_StateAttGetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttGet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttGet1DI2 
#endif 
 module procedure ESMF_StateAttGet1DI4 
 module procedure ESMF_StateAttGet1DI8 
 module procedure ESMF_StateAttGet1DR4 
 module procedure ESMF_StateAttGet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_StateAttGetLgcl
        module procedure ESMF_StateAttGetLgclList
        module procedure ESMF_StateAttGetChar
        module procedure ESMF_StateAttGetCharList
        module procedure ESMF_StateAttGetInfoByNam
        module procedure ESMF_StateAttGetInfoByNum
        module procedure ESMF_StateAttGetCount

! !DESCRIPTION:
! This interface provides a single entry point for methods that retrieve
! Attributes.

!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeLink - Link Attribute hierarchies
!
! !INTERFACE:
      interface ESMF_AttributeLink

! !PRIVATE MEMBER FUNCTIONS:
! TODO
        module procedure ESMF_ArrayBundleAttLinkArray
        module procedure ESMF_CplCompAttLinkCplComp
        module procedure ESMF_CplCompAttLinkGridComp
        module procedure ESMF_CplCompAttLinkState
        module procedure ESMF_FieldBundleAttLinkField
        module procedure ESMF_FieldBundleAttLinkGrid
        module procedure ESMF_FieldAttLinkGrid
        module procedure ESMF_GridCompAttLinkCplComp
        module procedure ESMF_GridCompAttLinkGridComp
        module procedure ESMF_GridCompAttLinkState
        module procedure ESMF_StateAttLinkArrayBundle
        module procedure ESMF_StateAttLinkArray
        module procedure ESMF_StateAttLinkFieldBundle
        module procedure ESMF_StateAttLinkField
        module procedure ESMF_StateAttLinkState

! !DESCRIPTION:
! This interface provides a single entry point for methods that link
! Attribute hierarchies.

!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink Attribute hierarchies
!
! !INTERFACE:
      interface ESMF_AttributeLinkRemove

! !PRIVATE MEMBER FUNCTIONS:
! TODO
        module procedure ESMF_ArrayBundleAttLinkRmArray
        module procedure ESMF_CplCompAttLinkRmCplComp
        module procedure ESMF_CplCompAttLinkRmGridComp
        module procedure ESMF_CplCompAttLinkRmState
        module procedure ESMF_FieldBundleAttLinkRmField
        module procedure ESMF_FieldBundleAttLinkRmGrid
        module procedure ESMF_FieldAttLinkRmGrid
        module procedure ESMF_GridCompAttLinkRmCplComp
        module procedure ESMF_GridCompAttLinkRmGridComp
        module procedure ESMF_GridCompAttLinkRmState
        module procedure ESMF_StateAttLinkRmArrayBundle
        module procedure ESMF_StateAttLinkRmArray
        module procedure ESMF_StateAttLinkRmFieldBundle
        module procedure ESMF_StateAttLinkRmField
        module procedure ESMF_StateAttLinkRmState

! !DESCRIPTION:
! This interface provides a single entry point for methods that unlink
! Attribute hierarchies.

!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRead - Read an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRead

! !PRIVATE MEMBER FUNCTIONS:
! TODO
! module procedure ESMF_ArrayAttRead
! module procedure ESMF_ArrayBundleAttRead
        module procedure ESMF_CplCompAttRead
        module procedure ESMF_GridCompAttRead
! module procedure ESMF_DistGridAttRead
        module procedure ESMF_FieldAttRead
        module procedure ESMF_FieldBundleAttRead
        module procedure ESMF_GridAttRead
        module procedure ESMF_StateAttRead

! !DESCRIPTION:
! This interface provides a single entry point for methods that read
! an Attribute or Attribute package.

!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeSet - Set Attributes and Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeSet

! !PRIVATE MEMBER FUNCTIONS:
 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttSetI2 
#endif 
 module procedure ESMF_ArrayAttSetI4 
 module procedure ESMF_ArrayAttSetI8 
 module procedure ESMF_ArrayAttSetR4 
 module procedure ESMF_ArrayAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayAttSet1DI2 
#endif 
 module procedure ESMF_ArrayAttSet1DI4 
 module procedure ESMF_ArrayAttSet1DI8 
 module procedure ESMF_ArrayAttSet1DR4 
 module procedure ESMF_ArrayAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayAttSetLgcl
        module procedure ESMF_ArrayAttSetLgclList
        module procedure ESMF_ArrayAttSetChar
        module procedure ESMF_ArrayAttSetCharList

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttSetI2 
#endif 
 module procedure ESMF_ArrayBundleAttSetI4 
 module procedure ESMF_ArrayBundleAttSetI8 
 module procedure ESMF_ArrayBundleAttSetR4 
 module procedure ESMF_ArrayBundleAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_ArrayBundleAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_ArrayBundleAttSet1DI2 
#endif 
 module procedure ESMF_ArrayBundleAttSet1DI4 
 module procedure ESMF_ArrayBundleAttSet1DI8 
 module procedure ESMF_ArrayBundleAttSet1DR4 
 module procedure ESMF_ArrayBundleAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_ArrayBundleAttSetLgcl
        module procedure ESMF_ArrayBundleAttSetLgclList
        module procedure ESMF_ArrayBundleAttSetChar
        module procedure ESMF_ArrayBundleAttSetCharList

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttSetI2 
#endif 
 module procedure ESMF_CplCompAttSetI4 
 module procedure ESMF_CplCompAttSetI8 
 module procedure ESMF_CplCompAttSetR4 
 module procedure ESMF_CplCompAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_CplCompAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_CplCompAttSet1DI2 
#endif 
 module procedure ESMF_CplCompAttSet1DI4 
 module procedure ESMF_CplCompAttSet1DI8 
 module procedure ESMF_CplCompAttSet1DR4 
 module procedure ESMF_CplCompAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_CplCompAttSetLgcl
        module procedure ESMF_CplCompAttSetLgclList
        module procedure ESMF_CplCompAttSetChar
        module procedure ESMF_CplCompAttSetCharList

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttSetI2 
#endif 
 module procedure ESMF_GridCompAttSetI4 
 module procedure ESMF_GridCompAttSetI8 
 module procedure ESMF_GridCompAttSetR4 
 module procedure ESMF_GridCompAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridCompAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridCompAttSet1DI2 
#endif 
 module procedure ESMF_GridCompAttSet1DI4 
 module procedure ESMF_GridCompAttSet1DI8 
 module procedure ESMF_GridCompAttSet1DR4 
 module procedure ESMF_GridCompAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridCompAttSetLgcl
        module procedure ESMF_GridCompAttSetLgclList
        module procedure ESMF_GridCompAttSetChar
        module procedure ESMF_GridCompAttSetCharList

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttSetI2 
#endif 
 module procedure ESMF_DistGridAttSetI4 
 module procedure ESMF_DistGridAttSetI8 
 module procedure ESMF_DistGridAttSetR4 
 module procedure ESMF_DistGridAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_DistGridAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_DistGridAttSet1DI2 
#endif 
 module procedure ESMF_DistGridAttSet1DI4 
 module procedure ESMF_DistGridAttSet1DI8 
 module procedure ESMF_DistGridAttSet1DR4 
 module procedure ESMF_DistGridAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_DistGridAttSetLgcl
        module procedure ESMF_DistGridAttSetLgclList
        module procedure ESMF_DistGridAttSetChar
        module procedure ESMF_DistGridAttSetCharList

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttSetI2 
#endif 
 module procedure ESMF_FieldAttSetI4 
 module procedure ESMF_FieldAttSetI8 
 module procedure ESMF_FieldAttSetR4 
 module procedure ESMF_FieldAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldAttSet1DI2 
#endif 
 module procedure ESMF_FieldAttSet1DI4 
 module procedure ESMF_FieldAttSet1DI8 
 module procedure ESMF_FieldAttSet1DR4 
 module procedure ESMF_FieldAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldAttSetLgcl
        module procedure ESMF_FieldAttSetLgclList
        module procedure ESMF_FieldAttSetChar
        module procedure ESMF_FieldAttSetCharList

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttSetI2 
#endif 
 module procedure ESMF_FieldBundleAttSetI4 
 module procedure ESMF_FieldBundleAttSetI8 
 module procedure ESMF_FieldBundleAttSetR4 
 module procedure ESMF_FieldBundleAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_FieldBundleAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_FieldBundleAttSet1DI2 
#endif 
 module procedure ESMF_FieldBundleAttSet1DI4 
 module procedure ESMF_FieldBundleAttSet1DI8 
 module procedure ESMF_FieldBundleAttSet1DR4 
 module procedure ESMF_FieldBundleAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_FieldBundleAttSetLgcl
        module procedure ESMF_FieldBundleAttSetLgclList
        module procedure ESMF_FieldBundleAttSetChar
        module procedure ESMF_FieldBundleAttSetCharList

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttSetI2 
#endif 
 module procedure ESMF_GridAttSetI4 
 module procedure ESMF_GridAttSetI8 
 module procedure ESMF_GridAttSetR4 
 module procedure ESMF_GridAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_GridAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_GridAttSet1DI2 
#endif 
 module procedure ESMF_GridAttSet1DI4 
 module procedure ESMF_GridAttSet1DI8 
 module procedure ESMF_GridAttSet1DR4 
 module procedure ESMF_GridAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_GridAttSetLgcl
        module procedure ESMF_GridAttSetLgclList
        module procedure ESMF_GridAttSetChar
        module procedure ESMF_GridAttSetCharList

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttSetI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttSetI2 
#endif 
 module procedure ESMF_StateAttSetI4 
 module procedure ESMF_StateAttSetI8 
 module procedure ESMF_StateAttSetR4 
 module procedure ESMF_StateAttSetR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

 !------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
#ifndef ESMF_NO_INTEGER_1_BYTE 
 module procedure ESMF_StateAttSet1DI1 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 
 module procedure ESMF_StateAttSet1DI2 
#endif 
 module procedure ESMF_StateAttSet1DI4 
 module procedure ESMF_StateAttSet1DI8 
 module procedure ESMF_StateAttSet1DR4 
 module procedure ESMF_StateAttSet1DR8 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

        module procedure ESMF_StateAttSetLgcl
        module procedure ESMF_StateAttSetLgclList
        module procedure ESMF_StateAttSetChar
        module procedure ESMF_StateAttSetCharList

! !DESCRIPTION:
! This interface provides a single entry point for methods that attach
! Attributes and Attribute packages, and link Attribute hierarchies.

!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeWrite

! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttWrite
        module procedure ESMF_ArrayBundleAttWrite
        module procedure ESMF_CplCompAttWrite
        module procedure ESMF_GridCompAttWrite
        !module procedure ESMF_DistGridAttWrite
        module procedure ESMF_FieldAttWrite
        module procedure ESMF_FieldBundleAttWrite
        !module procedure ESMF_GridAttWrite
        module procedure ESMF_StateAttWrite

! !DESCRIPTION:
! This interface provides a single entry point for methods that write
! an Attribute or Attribute package.

!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeUpdate

! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_CplCompAttUpdate
        module procedure ESMF_GridCompAttUpdate
        module procedure ESMF_FieldAttUpdate
        module procedure ESMF_FieldBundleAttUpdate
        module procedure ESMF_StateAttUpdate

! !DESCRIPTION:
! This interface provides a single entry point for methods that update
! an Attribute hierarchy.

!EOPI
      end interface

!
!------------------------------------------------------------------------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd - Add an ESMF standard Attribute package
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackStandard(<object>, convention, purpose, nestConvention, &
! nestPurpose, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: convention
! character (len = *), intent(in) :: purpose
! character (len = *), intent(in), optional :: nestConvention
! character (len = *), intent(in), optional :: nestPurpose
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add an ESMF standard Attribute package. See Section~\ref{desc:AttPacks}
! for a description of Attribute packages and their conventions, purposes,
! and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [convention]
! The convention of the new Attribute package
! \item [purpose]
! The purpose of the new Attribute package
! \item [{[nestConvention]}]
! The convention of the Attribute package around which to nest the
! new Attribute package
! \item [{[nestPurpose]}]
! The purpose of the Attribute package around which to nest the
! new Attribute package
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd - Add a custom Attribute package or modify an existing Attribute package
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeAdd()
! subroutine ESMF_AttAddPackCstm(<object>, convention, purpose, &
! attrList, count, nestConvention, nestPurpose, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! character (len=*), dimension(:), intent(in) :: attrList
! integer, intent(in), optional :: count
! character (len = *), intent(in), optional :: nestConvention
! character (len = *), intent(in), optional :: nestPurpose
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Add a custom Attribute package to <object>.
! See Section~\ref{desc:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [convention]
! The convention of the Attribute package
! \item [purpose]
! The purpose of the Attribute package
! \item [attrList]
! The list of Attribute names to specify the custom Attribute package
! \item [{[count]}]
! The number of Attributes to add to the custom Attribute package
! \item [{[nestConvention]}]
! The convention of the Attribute package around which to nest the
! new Attribute package
! \item [{[nestPurpose]}]
! The purpose of the Attribute package around which to nest the
! new Attribute package
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeCopy()
! subroutine ESMF_AttributeCopy(<object1>, <object2>, attcopyflag, atttreeflag, rc)
!
! !ARGUMENTS:
! <object1>, see below for supported values
! <object2>, see below for supported values
! type(ESMF_AttCopyFlag), intent(in) :: attcopyflag
! type(ESMF_AttTreeFlag), intent(in) :: atttreeflag
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Copy an Attribute hierarchy from <object1> to <object2>.
! Supported values for <object1> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp1
! \item type(ESMF\_GridComp), intent(inout) :: comp1
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
! Supported values for <object2> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp2
! \item type(ESMF\_GridComp), intent(inout) :: comp2
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! NOTE: Copies between different ESMF objects are not possible at this time.
!
! The arguments are:
! \begin{description}
! \item [<object1>]
! An {\tt ESMF} object
! \item [<object2>]
! An {\tt ESMF} object
! \item [attcopyflag]
! A flag to determine if the copy is to be by reference, value,
! or both
! \item [atttreeflag]
! A flag to determine if the copy is supposed to descend the
! Attribute hierarchy
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
! NOTE: Not all combinations of copy flags are enabled at this time. See
! the reference manual for an overview of the options available for
! {\tt ESMF\_AttributeCopy()}.
! The options for {\tt attcopyflag} include:
! \begin{enumerate}
! \item ESMF\_ATTCOPY\_HYBRID will copy the top base level
! Attributes by value, and all others by reference
! \item ESMF\_ATTCOPY\_REFERENCE will copy all Attributes by reference
! \item ESMF\_ATTCOPY\_VALUE will copy all Attributes by value
! \end{enumerate}
! The options for {\tt atttreeflag} include:
! \begin{enumerate}
! \item ESMF\_ATTTREE\_OFF will only descend the first base level
! of the Attribute hierarchy
! \item ESMF\_ATTTREE\_ON will descend the entire Attribute hierarchy
! \end{enumerate}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute
!
! !INTERFACE:
! subroutine ESMF_AttributeGet(<object>, name, <value argument>, &
! <defaultvalue argument>, convention, purpose, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <value argument>, see below for supported values
! <defaultvalue argument>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return an Attribute value from the <object>, or from the Attribute package
! specified by {\tt convention} and {\tt purpose}. A default value
! argument may be given if a return code is not desired when the
! Attribute is not found. See Section~\ref{desc:AttPacks} for a
! description of Attribute packages and their conventions, purposes,
! and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
! Supported values for <value argument> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out) :: value
! \item integer(ESMF\_KIND\_I8), intent(out) :: value
! \item real (ESMF\_KIND\_R4), intent(out) :: value
! \item real (ESMF\_KIND\_R8), intent(out) :: value
! \item logical, intent(out) :: value
! \item character (len = *), intent(out), value
! \end{description}
! Supported values for <defaultvalue argument> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(out), optional :: defaultvalue
! \item integer(ESMF\_KIND\_I8), intent(out), optional :: defaultvalue
! \item real (ESMF\_KIND\_R4), intent(out), optional :: defaultvalue
! \item real (ESMF\_KIND\_R8), intent(out), optional :: defaultvalue
! \item logical, intent(out), optional :: defaultvalue
! \item character (len = *), intent(out), optional :: defaultvalue
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [name]
! The name of the Attribute to retrieve
! \item [<value argument>]
! The value of the named Attribute
! \item [{[<defaultvalue argument>]}]
! The default value of the named Attribute
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get an Attribute
!
! !INTERFACE:
! subroutine ESMF_AttributeGet(<object>, name, <valueList argument>, &
! <defaultvalueList argument>, convention, purpose, &
! itemCount, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <valueList argument>, see below for supported values
! <defaultvalueList argument>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! integer, intent(inout), optional :: itemCount
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return an Attribute value from the <object>, or from the Attribute package
! specified by {\tt convention} and {\tt purpose}. A default value
! argument may be given if a return code is not desired when the
! Attribute is not found. See Section~\ref{desc:AttPacks} for a
! description of Attribute packages and their conventions, purposes,
! and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
! Supported values for <value argument> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), dimension(:), intent(out) :: valueList
! \item integer(ESMF\_KIND\_I8), dimension(:), intent(out) :: valueList
! \item real (ESMF\_KIND\_R4), dimension(:), intent(out) :: valueList
! \item real (ESMF\_KIND\_R8), dimension(:), intent(out) :: valueList
! \item logical, dimension(:), intent(out) :: valueList
! \item character (len = *), dimension(count), intent(out) :: valueList
! \end{description}
! Supported values for <defaultvalue argument> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), dimension(:), intent(out), optional :: defaultvalueList
! \item integer(ESMF\_KIND\_I8), dimension(:), intent(out), optional :: defaultvalueList
! \item real (ESMF\_KIND\_R4), dimension(:), intent(out), optional :: defaultvalueList
! \item real (ESMF\_KIND\_R8), dimension(:), intent(out), optional :: defaultvalueList
! \item logical, dimension(:), intent(out), optional :: defaultvalueList
! \item character (len = *), dimension(:), intent(out), optional :: defaultvalueList
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [name]
! The name of the Attribute to retrieve
! \item [<valueList argument>]
! The valueList of the named Attribute
! \item [{[<defaultvalueList argument>]}]
! The default value list of the named Attribute
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[itemCount]}]
! The number of items in a multi-valued Attribute. If the itemCount is passed in, only itemCount
! items of the desired Attribute will be returned, as long as there is enough space and there are
! itemCount items to return. Regardless of whether itemCount is passed in, it will be returned as the
! number of items that was {\it actually} returned.
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get the Attribute count
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetCount(<object>, count, attcountflag, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! integer, intent(out) :: count
! type(ESMF_AttCountFlag), intent(in), optional :: attcountflag
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return the Attribute count for <object>.
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [count]
! The Attribute count for <object>
! \item [{[attcountflag]}]
! The flag to specify which attribute count to return, the
! default is ESMF\_ATTGETCOUNT\_ATTRIBUTE (see below)
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
! NOTE: The options for {\tt attcountflag} include:
! \begin{enumerate}
! \item ESMF\_ATTGETCOUNT\_ATTRIBUTE will get the number of single Attributes
! \item ESMF\_ATTGETCOUNT\_ATTPACK will get the number of Attribute packages
! \item ESMF\_ATTGETCOUNT\_ATTLINK will get the number of Attribute links
! \item ESMF\_ATTGETCOUNT\_TOTAL will get the total number of Attributes
! \end{enumerate}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by name
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetInfoByNam(<object>, name, typekind, itemCount, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! type(ESMF_TypeKind), intent(out), optional :: typekind
! integer, intent(out), optional :: itemCount
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Return information associated with the named Attribute,
! including {\tt typekind} and {\tt itemCount}.
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [name]
! The name of the Attribute to query
! \item [{[typekind}]]
! The typekind of the Attribute
! \item [{[itemCount]}]
! The number of items in this Attribute
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by index number
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeGet()
! subroutine ESMF_AttributeGetInfoByNum(<object>, attributeIndex, name, &
! typekind, itemcount, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! integer, intent(in) :: attributeIndex
! character (len = *), intent(out) :: name
! type(ESMF_TypeKind), intent(out), optional :: typekind
! integer, intent(out), optional :: itemCount
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Returns information associated with the indexed Attribute,
! including {\tt name}, {\tt typekind} and {\tt itemCount}. Keep in
! mind that these indexes start from 1, as expected in a Fortran API.
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [attributeIndex]
! The index number of the Attribute to query
! \item [name]
! The name of the Attribute
! \item [{[typekind]}]
! The typekind of the Attribute
! \item [{[itemCount]}]
! The number of items in this Attribute
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a Component Attribute hierarchy to that of a Component or State
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_CompAttLink(<object1>, <object2>, rc)
!
! !ARGUMENTS:
! <object1>, see below for supported values
! <object2>, see below for supported values
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach a {\tt CplComp} or {\tt GridComp} Attribute hierarchy to the
! hierarchy of a {\tt CplComp}, {\tt GridComp}, or {\tt State}.
! Supported values for the <object1> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp1
! \item type(ESMF\_GridComp), intent(inout) :: comp1
! \end{description}
! Supported values for the <object2> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp2
! \item type(ESMF\_GridComp), intent(inout) :: comp2
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object1>]
! The ``parent'' object in the Attribute hierarchy link
! \item [<object2>]
! The ``child'' object in the Attribute hierarchy link
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a State Attribute hierarchy with the
! hierarchy of a an Array, ArrayBundle, Field, FieldBundle, or State
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_StateAttLink(state, <object>, rc)
!
! !ARGUMENTS:
! type(ESMF\_State), intent(inout) :: state
! <object>, see below for supported values
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach a {\tt State} Attribute hierarchy to the hierarchy of
! a {\tt Fieldbundle}, {\tt Field}, or another {\tt State}.
! Supported values for the <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [state]
! An {\tt ESMF\_State} object
! \item [<object>]
! The object with which to link hierarchies
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a FieldBundle and Field Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_FieldBundleAttLink(fieldbundle, field, rc)
!
! !ARGUMENTS:
! type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! type(ESMF\_Field), intent(inout) :: field
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach a {\tt FieldBundle} Attribute hierarchy to the hierarchy of
! a {\tt Field}.
!
! The arguments are:
! \begin{description}
! \item [fieldbundle]
! An {\tt ESMF\_FieldBundle} object
! \item [field]
! An {\tt ESMF\_Field} object
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link a Field and Grid Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_FieldAttLink(field, grid, rc)
!
! !ARGUMENTS:
! type(ESMF\_Field), intent(inout) :: field
! type(ESMF\_Grid), intent(inout) :: grid
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach a {\tt Field} Attribute hierarchy to the hierarchy of
! a {\tt Grid}.
!
! The arguments are:
! \begin{description}
! \item [field]
! An {\tt ESMF\_Field} object
! \item [grid]
! An {\tt ESMF\_Grid} object
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLink - Link an ArrayBundle and Array Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLink()
! subroutine ESMF_ArrayBundleAttLink(arraybundle, array, rc)
!
! !ARGUMENTS:
! type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! type(ESMF\_Array), intent(inout) :: array
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Attach an {\tt ArrayBundle} Attribute hierarchy to the hierarchy of
! an {\tt Array}.
!
! The arguments are:
! \begin{description}
! \item [arraybundle]
! An {\tt ESMF\_ArrayBundle} object
! \item [array]
! An {\tt ESMF\_Array} object
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a Component Attribute hierarchy from that of a Component or State
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_CompAttLinkRemove(<object1>, <object2>, rc)
!
! !ARGUMENTS:
! <object1>, see below for supported values
! <object2>, see below for supported values
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach a {\tt CplComp} or {\tt GridComp} Attribute hierarchy from the
! hierarchy of a {\tt CplComp}, {\tt GridComp}, or {\tt State}.
! Supported values for the <object1> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp1
! \item type(ESMF\_GridComp), intent(inout) :: comp1
! \end{description}
! Supported values for the <object2> are:
! \begin{description}
! \item type(ESMF\_CplComp), intent(inout) :: comp2
! \item type(ESMF\_GridComp), intent(inout) :: comp2
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object1>]
! The ``parent'' object in the Attribute hierarchy link
! \item [<object2>]
! The ``child'' object in the Attribute hierarchy link
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a State Attribute hierarchy with
! the hierarchy of an Array, ArrayBundle, Field, FieldBundle, or State
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_StateAttLinkRemove(state, <object>, rc)
!
! !ARGUMENTS:
! type(ESMF\_State), intent(inout) :: state
! <object>, see below for supported values
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach a {\tt State} Attribute hierarchy from the hierarchy of
! a {\tt Fieldbundle}, {\tt Field}, or another {\tt State}.
! Supported values for the <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [state]
! An {\tt ESMF\_State} object
! \item [<object>]
! The object with which to unlink hierarchies
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a FieldBundle and Field Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_FieldBundleAttLinkRemove(fieldbundle, field, rc)
!
! !ARGUMENTS:
! type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! type(ESMF\_Field), intent(inout) :: field
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach a {\tt FieldBundle} Attribute hierarchy from the hierarchy of
! a {\tt Field}.
!
! The arguments are:
! \begin{description}
! \item [fieldbundle]
! An {\tt ESMF\_FieldBundle} object
! \item [field]
! An {\tt ESMF\_Field} object
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink a Field and Grid Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_FieldAttLinkRemove(field, grid, rc)
!
! !ARGUMENTS:
! type(ESMF\_Field), intent(inout) :: field
! type(ESMF\_Grid), intent(inout) :: grid
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach a {\tt Field} Attribute hierarchy from the hierarchy of
! a {\tt Grid}.
!
! The arguments are:
! \begin{description}
! \item [field]
! An {\tt ESMF\_Field} object
! \item [grid]
! An {\tt ESMF\_Grid} object
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink an ArrayBundle and Array Attribute hierarchy
!
! !INTERFACE:
! ! Private name; call using ESMF_AttributeLinkRemove()
! subroutine ESMF_ArrayBundleAttLinkRemove(arraybundle, array, rc)
!
! !ARGUMENTS:
! type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! type(ESMF\_Array), intent(inout) :: array
! integer, intent(out), optional :: rc
!
!
! !DESCRIPTION:
! Unattach an {\tt ArrayBundle} Attribute hierarchy from the hierarchy of
! an {\tt Array}.
!
! The arguments are:
! \begin{description}
! \item [arraybundle]
! An {\tt ESMF\_ArrayBundle} object
! \item [array]
! An {\tt ESMF\_Array} object
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRead - Read Attributes from an XML file
!
! !INTERFACE:
! subroutine ESMF_AttributeRead(<object>, fileName, convention, purpose, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len=*), intent(in), optional :: fileName
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Read Attributes for <object>. If present, the convention and purpose
! specify an Attribute package which is used to filter the reading to just
! those attributes belonging to the Attribute package. The file format
! is XML. See Section~\ref{desc:AttPacks} for a description of Attribute
! packages and their conventions, purposes, and object types.
!
! Requires the third party Xerces C++ XML Parser library to be installed.
! For more details, see the "ESMF Users Guide",
! "Building and Installing the ESMF, Third Party Libraries, Xerces" and
! the website "http://xerces.apache.org/xerces-c".
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array ! not yet implemented
! \item type(ESMF\_ArrayBundle), intent(inout) :: arrayBundle ! not yet implemented
! \item type(ESMF\_CplComp), intent(inout) :: cplComp
! \item type(ESMF\_GridComp), intent(inout) :: gridComp
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldBundle ! not yet implemented
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_DistGrid), intent(inout) :: distGrid ! not yet implemented
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! The {\tt ESMF} object onto which the read Attributes will be placed
! \item[{[fileName]}]
! The name of the XML file to read
! \item [{[convention]}]
! The convention of the Attribute package to read
! \item [{[purpose]}]
! The purpose of the Attribute package to read
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute package
!
! !INTERFACE:
! subroutine ESMF_AttributeRemove(<object>, name, convention, purpose, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in), optional :: name
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Remove an Attribute, or Attribute package on <object>.
! See Section~\ref{desc:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [{[name]}]
! The name of the Attribute to remove
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
! NOTE: An entire Attribute package can be removed by specifying
! {\tt convention} and {\tt purpose} only, without {\tt name}. By specifying
! {\tt convention}, {\tt purpose}, and {\tt name} an Attribute will be removed
! from the corresponding Attribute package, if it exists. An
! Attribute can be removed directly from <object> by specifying
! {\tt name}, without {\tt convention} and {\tt purpose}.
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute
!
! !INTERFACE:
! subroutine ESMF_AttributeSet(<object>, name, <value argument>, &
! convention, purpose, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <value argument>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Attach an Attribute to <object>, or set an Attribute in an
! Attribute package. The Attribute has a {\tt name} and either
! a {\tt value}, and a {\tt convention} and {\tt purpose}.
! See Section~\ref{desc:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
! Supported values for the <value argument> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), intent(in) :: value
! \item integer(ESMF\_KIND\_I8), intent(in) :: value
! \item real (ESMF\_KIND\_R4), intent(in) :: value
! \item real (ESMF\_KIND\_R8), intent(in) :: value
! \item logical, intent(in) :: value
! \item character (len = *), intent(in), :: value
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [name]
! The name of the Attribute to set
! \item [<value argument>]
! The value of the Attribute to set
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute
!
! !INTERFACE:
! subroutine ESMF_AttributeSet(<object>, name, <valueList argument>, &
! convention, purpose, itemCount, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in) :: name
! <valueList argument>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! integer, intent(in), optional :: itemCount
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Attach an Attribute to <object>, or set an Attribute in an
! Attribute package. The Attribute has a {\tt name} and a
! {\tt valueList}, with an {\tt itemCount}, and a {\tt convention}
! and {\tt purpose}. See Section~\ref{desc:AttPacks} for a description
! of Attribute packages and their conventions, purposes, and object types.
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_DistGrid), intent(inout) :: distgrid
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_Grid), intent(inout) :: grid
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
! Supported values for the <value argument> are:
! \begin{description}
! \item integer(ESMF\_KIND\_I4), dimension(:), intent(in) :: valueList
! \item integer(ESMF\_KIND\_I8), dimension(:), intent(in) :: valueList
! \item real (ESMF\_KIND\_R4), dimension(:), intent(in) :: valueList
! \item real (ESMF\_KIND\_R8), dimension(:), intent(in) :: valueList
! \item logical, dimension(:), intent(in) :: valueList
! \item character (len = *), dimension(:), intent(in), :: valueList
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [name]
! The name of the Attribute to set
! \item [<valueList argument>]
! The valueList of the Attribute to set
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[itemCount]}]
! The number of items in a multi-valued Attribute
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
! subroutine ESMF_AttributeUpdate(<object>, vm, rootList, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! type(ESMF_VM), intent(in) :: vm
! integer, dimension(:), intent(in) :: rootList
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Update an Attribute hierarchy during runtime.
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [vm]
! The virtural machine over which this Attribute hierarchy
! should be updated
! \item [rootList]
! The list of ``root'' PETs that are to be used to update
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package
!
! !INTERFACE:
! subroutine ESMF_AttributeWrite(<object>, convention, purpose, attwriteflag, rc)
!
! !ARGUMENTS:
! <object>, see below for supported values
! character (len = *), intent(in), optional :: convention
! character (len = *), intent(in), optional :: purpose
! type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
! integer, intent(out), optional :: rc
!
! !DESCRIPTION:
! Write the Attribute package for <object>. The Attribute package defines
! the convention, purpose, and object type of the associated Attributes. Either
! tab-delimited or xml format is acheived by using {\tt attwriteflag}.
! See Section~\ref{desc:AttPacks} for a description of Attribute packages
! and their conventions, purposes, and object types.
!
! Note: For an object type of {\tt ESMF\_GridComp}, convention='WaterML',
! purpose='TimeSeries', and attwriteflag=ESMF\_ATTWRITE\_XML, an XML file
! conforming to a hydrologic standard called WaterML will be written. See
! the following for more information:
!
! \begin{description}
! \item{"http://his.cuahsi.org/wofws.html"}
! \item{"http://www.earthsystemcurator.org/projects/waterml.shtml"}
! \end{description}
!
! An ESMF Use Test Case is available which showcases an example of how
! to write a WaterML file; please see
!
! \begin{description}
! \item{"http://esmf.cvs.sourceforge.net/viewvc/esmf/use\_test\_cases/ESMF\_WaterML"}
! \item{"http://esmf.cvs.sourceforge.net/viewvc/esmf/use\_test\_cases/README"}
! \end{description}
!
! Supported values for <object> are:
! \begin{description}
! \item type(ESMF\_Array), intent(inout) :: array
! \item type(ESMF\_ArrayBundle), intent(inout) :: arraybundle
! \item type(ESMF\_CplComp), intent(inout) :: comp
! \item type(ESMF\_GridComp), intent(inout) :: comp
! \item type(ESMF\_Field), intent(inout) :: field
! \item type(ESMF\_FieldBundle), intent(inout) :: fieldbundle
! \item type(ESMF\_State), intent(inout) :: state
! \end{description}
!
! The arguments are:
! \begin{description}
! \item [<object>]
! An {\tt ESMF} object
! \item [{[convention]}]
! The convention of the Attribute package
! \item [{[purpose]}]
! The purpose of the Attribute package
! \item [{[attwriteflag]}]
! The flag to specify which format is desired for the write, the
! default is tab-delimited
! \item [{[rc]}]
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors
! \end{description}
!
! NOTE: The options for {\tt attwriteflag} include:
! \begin{enumerate}
! \item ESMF\_ATTWRITE\_XML will write in xml format
! \item ESMF\_ATTWRITE\_TAB will write in tab-delimited format
! \end{enumerate}
!
!EOP
!------------------------------------------------------------------------------


!-------------------------------------------------------------------------
! Macro versions of the routines
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!------------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!-------------------------------------------------------------------------
! ARRAY
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstm" 
!BOPI 
! !IROUTINE: AttAddPackCstm - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayAttAddPackCstm(array, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an 
! existing Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [count] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="array" 
 type(ESMF_Logical) :: attpacknest 

 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 if (localCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "attrList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateCustom(array, convention, & 
 purpose, object, localrc) 
 else 
 call c_ESMC_AttPackNest(array, convention, & 
 purpose, object, nestConvention, nestPurpose, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(array, attrList(i), convention, & 
 purpose, object, localrc) 
 end do 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttAddPackCstm 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStandard" 
 
!BOPI 
! !IROUTINE: AttAddPackStandard - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayAttAddPackStd(array, convention, purpose, & 
 nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An {\tt ESMF_Array} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: attpacknest 
 character (len=*), parameter :: object="array" 
 
 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (convention .ne. "ESMF" .or. purpose .ne. "General") then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "Convention must be ESMF, and purpose must be General for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE; 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateStandard(array, convention, & 
 purpose, object, localrc) 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & 
 "cannot nest an ESMF standard Attribute package onto a custom package", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_ArrayAttRemove(array, name, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(array, convention, & 
 purpose, fobject, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(array, name, convention, & 
 purpose, fobject, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(array, name, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetI1(array, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DI1(array, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetI2(array, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DI2(array, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetI4(array, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DI4(array, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetI8(array, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DI8(array, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetR4(array, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DR4(array, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetR8(array, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGet1DR8(array, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetLgcl(array, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [defaultvalue] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: localvalue, present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetLgclList(array, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [defaultvalueList] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of values in the Attribute. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetChar(array, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [defaultvalue] 
! The character default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetChar(array, name, value, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetChar(array, name, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_ArrayAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetCharList(array, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [defaultvalueList] 
! The character list default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The itemCount of the character items to retrieve 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: present_flag, attpack 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 do i=1,litemCount 
 lens(i) = len (valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(array, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(array, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetCount(array, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(array, count, lattcountflag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetInfoByNam(array, name, typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character(len=*), intent(in) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 call c_ESMC_AttributeGetInfoName(array, name, & 
 localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayAttGetInfoByNum(array, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character types, 
! this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 call c_ESMC_AttributeGetInfoNum(array, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttGetInfoByNum 
 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetI1(array, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DI1(array, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetI2(array, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DI2(array, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetI4(array, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DI4(array, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetI8(array, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DI8(array, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetR4(array, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DR4(array, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetR8(array, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSet1DR8(array, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetLgcl(array, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetLgclList(array, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(array, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetChar(array, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetChar(array, name, value, & 
 ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetChar(array, name, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayAttSetCharList(array, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="array" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(array, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_ArrayAttUpdate(array, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [array] 
! An {\tt ESMF_Array} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(array, vm, rootList, count, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_ArrayAttWrite(array, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_Array), intent(inout) :: array 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="array" 
 character(len=*), parameter :: ftarobj="array" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(array, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(array, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayAttWrite 

!-------------------------------------------------------------------------
! ARRAYBUNDLE
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstm" 
!BOPI 
! !IROUTINE: AttAddPackCstm - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayBundleAttAddPackCstm(arraybundle, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an 
! existing Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [count] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="arraybundle" 
 type(ESMF_Logical) :: attpacknest 

 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 if (localCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "attrList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateCustom(arraybundle, convention, & 
 purpose, object, localrc) 
 else 
 call c_ESMC_AttPackNest(arraybundle, convention, & 
 purpose, object, nestConvention, nestPurpose, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(arraybundle, attrList(i), convention, & 
 purpose, object, localrc) 
 end do 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttAddPackCstm 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStandard" 
 
!BOPI 
! !IROUTINE: AttAddPackStandard - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_ArrayBundleAttAddPackStd(arraybundle, convention, purpose, & 
 nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: attpacknest 
 character (len=*), parameter :: object="arraybundle" 
 
 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (convention .ne. "ESMF" .or. purpose .ne. "General") then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "Convention must be ESMF, and purpose must be General for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE; 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateStandard(arraybundle, convention, & 
 purpose, object, localrc) 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & 
 "cannot nest an ESMF standard Attribute package onto a custom package", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_ArrayBundleAttRemove(arraybundle, name, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(arraybundle, convention, & 
 purpose, fobject, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(arraybundle, name, convention, & 
 purpose, fobject, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(arraybundle, name, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetI1(arraybundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DI1(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetI2(arraybundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DI2(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetI4(arraybundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DI4(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetI8(arraybundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DI8(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetR4(arraybundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DR4(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetR8(arraybundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGet1DR8(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetLgcl(arraybundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [defaultvalue] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: localvalue, present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetLgclList(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [defaultvalueList] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of values in the Attribute. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetChar(arraybundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [defaultvalue] 
! The character default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetChar(arraybundle, name, value, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetChar(arraybundle, name, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_ArrayBundleAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetCharList(arraybundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [defaultvalueList] 
! The character list default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The itemCount of the character items to retrieve 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 do i=1,litemCount 
 lens(i) = len (valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(arraybundle, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(arraybundle, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetCount(arraybundle, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(arraybundle, count, lattcountflag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetInfoByNam(arraybundle, name, typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character(len=*), intent(in) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 call c_ESMC_AttributeGetInfoName(arraybundle, name, & 
 localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_ArrayBundleAttGetInfoByNum(arraybundle, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character types, 
! this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 call c_ESMC_AttributeGetInfoNum(arraybundle, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_ArrayBundleAttLinkArray(arraybundle, array, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 type(ESMF_Array), intent(inout) :: array 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! \item [array] 
! An {\tt ESMF_Array} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 call c_ESMC_AttributeLink(& 
 arraybundle, array, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttLinkArray 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_ArrayBundleAttLinkRmArray(arraybundle, array, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 type(ESMF_Array), intent(inout) :: array 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! \item [array] 
! An {\tt ESMF_Array} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 arraybundle, array, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttLinkRmArray 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetI1(arraybundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DI1(arraybundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetI2(arraybundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DI2(arraybundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetI4(arraybundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DI4(arraybundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetI8(arraybundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DI8(arraybundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetR4(arraybundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DR4(arraybundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetR8(arraybundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSet1DR8(arraybundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetLgcl(arraybundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetLgclList(arraybundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(arraybundle, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetChar(arraybundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetChar(arraybundle, name, value, & 
 ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetChar(arraybundle, name, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_ArrayBundleAttSetCharList(arraybundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="arraybundle" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(arraybundle, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_ArrayBundleAttUpdate(arraybundle, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(arraybundle, vm, rootList, count, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_ArrayBundleAttWrite(arraybundle, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="arraybundle" 
 character(len=*), parameter :: ftarobj="array" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(arraybundle, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(arraybundle, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_ArrayBundleAttWrite 

!-------------------------------------------------------------------------
! CplComp
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStandard" 
 
!BOPI 
! !IROUTINE: AttAddPackStandard - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackStd(comp, convention, purpose, & 
 nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: attpacknest 
 character (len=*), parameter :: object="comp" 
 
 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (convention .ne. "ESMF" .or. purpose .ne. "General") then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "Convention must be ESMF, and purpose must be General for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE; 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateStandard(comp%compp%base, convention, & 
 purpose, object, localrc) 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & 
 "cannot nest an ESMF standard Attribute package onto a custom package", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstm" 
!BOPI 
! !IROUTINE: AttAddPackCstm - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_CplCompAttAddPackCstm(comp, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an 
! existing Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [count] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="comp" 
 type(ESMF_Logical) :: attpacknest 

 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 if (localCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "attrList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateCustom(comp%compp%base, convention, & 
 purpose, object, localrc) 
 else 
 call c_ESMC_AttPackNest(comp%compp%base, convention, & 
 purpose, object, nestConvention, nestPurpose, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(comp%compp%base, attrList(i), convention, & 
 purpose, object, localrc) 
 end do 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttAddPackCstm 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_CplCompAttCopy(comp1, comp2, attcopyflag, atttreeflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(inout) :: comp2 
 type(ESMF_AttCopyFlag), intent(in) :: attcopyflag 
 type(ESMF_AttTreeFlag), intent(in) :: atttreeflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! \item [attcopyflag] 
! A flag to determine if the copy is to be by reference, value, or both 
! \item [atttreeflag] 
! A flag to determine if the copy is supposed to descend the Attribute 
! hierarchy 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 call c_ESMC_AttributeCopy(comp1%compp%base, comp2%compp%base, & 
 attcopyflag, atttreeflag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttCopy 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetI1(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DI1(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetI2(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DI2(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetI4(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DI4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetI8(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DI8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetR4(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DR4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetR8(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGet1DR8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetLgcl(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [defaultvalue] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: localvalue, present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetLgclList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [defaultvalueList] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of values in the Attribute. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetChar(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [defaultvalue] 
! The character default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetChar(comp%compp%base, name, value, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetChar(comp%compp%base, name, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_CplCompAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetCharList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [defaultvalueList] 
! The character list default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The itemCount of the character items to retrieve 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 do i=1,litemCount 
 lens(i) = len (valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetCount(comp, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(comp%compp%base, count, lattcountflag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetInfoByNam(comp, name, typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, & 
 localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_CplCompAttGetInfoByNum(comp, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character types, 
! this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 call c_ESMC_AttributeGetInfoNum(comp%compp%base, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_CplCompAttLinkCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_CplCompAttLinkGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_CplCompAttLinkState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_State), intent(inout) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, state%statep%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_CplCompAttLinkRmCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkRmCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_CplCompAttLinkRmGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_CplComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkRmGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_CplCompAttLinkRmState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_State), intent(inout) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, state%statep%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttLinkRmState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_CplCompAttRead(comp, fileName, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len=*), intent(in), optional :: fileName 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt comp}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item[{[fileName]}] 
! The file name to be read from. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, localrc 
 
 fileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS 
 !TODO: Remove the following dummy test when dummy argument actually used 
 if (convention == convention .and. purpose==purpose) continue 
 
 ! get length of given fileName for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 ! invoke C to C++ entry point 
 ! TODO: convention, purpose 
 call c_ESMC_AttributeRead(comp%compp%base, fileNameLen, fileName, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_CplCompAttRemove(comp, name, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(comp%compp%base, convention, & 
 purpose, fobject, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(comp%compp%base, name, convention, & 
 purpose, fobject, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(comp%compp%base, name, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetI1(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DI1(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetI2(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DI2(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetI4(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DI4(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetI8(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DI8(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetR4(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DR4(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetR8(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSet1DR8(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetLgcl(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetLgclList(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetChar(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetChar(comp%compp%base, name, value, & 
 ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetChar(comp%compp%base, name, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_CplCompAttSetCharList(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="comp" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_CplCompAttUpdate(comp, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_CplComp} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(comp%compp%base, vm, rootList, count, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_CplCompAttWrite(comp, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_CplComp), intent(inout) :: comp 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(comp%compp%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(comp%compp%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_CplCompAttWrite 

!-------------------------------------------------------------------------
! GridComp
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStandard" 
 
!BOPI 
! !IROUTINE: AttAddPackStandard - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackStd(comp, convention, purpose, & 
 nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: attpacknest 
 character (len=*), parameter :: object="comp" 
 
 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (convention .ne. "ESMF" .or. purpose .ne. "General") then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "Convention must be ESMF, and purpose must be General for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE; 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateStandard(comp%compp%base, convention, & 
 purpose, object, localrc) 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & 
 "cannot nest an ESMF standard Attribute package onto a custom package", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstm" 
!BOPI 
! !IROUTINE: AttAddPackCstm - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridCompAttAddPackCstm(comp, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an 
! existing Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [count] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="comp" 
 type(ESMF_Logical) :: attpacknest 

 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 if (localCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "attrList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateCustom(comp%compp%base, convention, & 
 purpose, object, localrc) 
 else 
 call c_ESMC_AttPackNest(comp%compp%base, convention, & 
 purpose, object, nestConvention, nestPurpose, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(comp%compp%base, attrList(i), convention, & 
 purpose, object, localrc) 
 end do 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttAddPackCstm 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_GridCompAttCopy(comp1, comp2, attcopyflag, atttreeflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(inout) :: comp2 
 type(ESMF_AttCopyFlag), intent(in) :: attcopyflag 
 type(ESMF_AttTreeFlag), intent(in) :: atttreeflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! \item [attcopyflag] 
! A flag to determine if the copy is to be by reference, value, or both 
! \item [atttreeflag] 
! A flag to determine if the copy is supposed to descend the Attribute 
! hierarchy 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 call c_ESMC_AttributeCopy(comp1%compp%base, comp2%compp%base, & 
 attcopyflag, atttreeflag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttCopy 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_GridCompAttRemove(comp, name, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(comp%compp%base, convention, & 
 purpose, fobject, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(comp%compp%base, name, convention, & 
 purpose, fobject, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(comp%compp%base, name, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetI1(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DI1(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetI2(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DI2(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetI4(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DI4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetI8(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DI8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetR4(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DR4(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetR8(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGet1DR8(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetLgcl(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [defaultvalue] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: localvalue, present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetLgclList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [defaultvalueList] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of values in the Attribute. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetChar(comp, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [defaultvalue] 
! The character default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetChar(comp%compp%base, name, value, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetChar(comp%compp%base, name, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_GridCompAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetCharList(comp, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [defaultvalueList] 
! The character list default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The itemCount of the character items to retrieve 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: present_flag, attpack 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 do i=1,litemCount 
 lens(i) = len (valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(comp%compp%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(comp%compp%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetCount(comp, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(comp%compp%base, count, lattcountflag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetInfoByNam(comp, name, typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 call c_ESMC_AttributeGetInfoName(comp%compp%base, name, & 
 localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridCompAttGetInfoByNum(comp, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character types, 
! this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 call c_ESMC_AttributeGetInfoNum(comp%compp%base, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_GridCompAttLinkCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_GridCompAttLinkGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 call c_ESMC_AttributeLink(& 
 comp1%compp%base, comp2%compp%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_GridCompAttLinkState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_State), intent(inout) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 call c_ESMC_AttributeLink(& 
 comp%compp%base, state%statep%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_GridCompAttLinkRmCplComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_CplComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_CplComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkRmCplComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_GridCompAttLinkRmGridComp(comp1, comp2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp1 
 type(ESMF_GridComp), intent(inout) :: comp2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp1] 
! An {\tt ESMF_GridComp} object. 
! \item [comp2] 
! An {\tt ESMF_GridComp} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 comp1%compp%base, comp2%compp%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkRmGridComp 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_GridCompAttLinkRmState(comp, state, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_State), intent(inout) :: state 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [state] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 comp%compp%base, state%statep%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttLinkRmState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_GridCompAttRead(comp, fileName, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len=*), intent(in), optional :: fileName 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt comp}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item[{[fileName]}] 
! The file name to be read from. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, localrc 
 
 fileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS 
 !TODO: Remove the following dummy test when dummy argument actually used 
 if (convention == convention .and. purpose==purpose) continue 
 
 ! get length of given fileName for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 ! invoke C to C++ entry point 
 ! TODO: convention, purpose 
 call c_ESMC_AttributeRead(comp%compp%base, fileNameLen, fileName, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttRead 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetI1(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DI1(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetI2(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DI2(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetI4(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DI4(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetI8(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DI8(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetR4(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DR4(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetR8(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSet1DR8(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetLgcl(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetLgclList(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(comp%compp%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetChar(comp, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetChar(comp%compp%base, name, value, & 
 ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetChar(comp%compp%base, name, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridCompAttSetCharList(comp, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="comp" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(comp%compp%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_GridCompAttUpdate(comp, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [comp] 
! An {\tt ESMF_GridComp} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(comp%compp%base, vm, rootList, count, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_GridCompAttWrite(comp, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_GridComp), intent(inout) :: comp 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="comp" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(comp%compp%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(comp%compp%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridCompAttWrite 

!-------------------------------------------------------------------------
! DISTGRID
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstm" 
!BOPI 
! !IROUTINE: AttAddPackCstm - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_DistGridAttAddPackCstm(distgrid, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an 
! existing Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [count] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="distgrid" 
 type(ESMF_Logical) :: attpacknest 

 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 if (localCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "attrList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateCustom(distgrid, convention, & 
 purpose, object, localrc) 
 else 
 call c_ESMC_AttPackNest(distgrid, convention, & 
 purpose, object, nestConvention, nestPurpose, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(distgrid, attrList(i), convention, & 
 purpose, object, localrc) 
 end do 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttAddPackCstm 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetI1(distgrid, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DI1(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetI2(distgrid, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DI2(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetI4(distgrid, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DI4(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetI8(distgrid, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DI8(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetR4(distgrid, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DR4(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetR8(distgrid, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGet1DR8(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetLgcl(distgrid, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [defaultvalue] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: localvalue, present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetLgclList(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [defaultvalueList] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of values in the Attribute. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetChar(distgrid, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [defaultvalue] 
! The character default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetChar(distgrid, name, value, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetChar(distgrid, name, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_DistGridAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetCharList(distgrid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [defaultvalueList] 
! The character list default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The itemCount of the character items to retrieve 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: present_flag, attpack 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 do i=1,litemCount 
 lens(i) = len (valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(distgrid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(distgrid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetCount(distgrid, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(distgrid, count, lattcountflag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetInfoByNam(distgrid, name, typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character(len=*), intent(in) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 call c_ESMC_AttributeGetInfoName(distgrid, name, & 
 localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_DistGridAttGetInfoByNum(distgrid, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character types, 
! this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 call c_ESMC_AttributeGetInfoNum(distgrid, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_DistGridAttRemove(distgrid, name, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(distgrid, convention, & 
 purpose, fobject, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(distgrid, name, convention, & 
 purpose, fobject, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(distgrid, name, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetI1(distgrid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DI1(distgrid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetI2(distgrid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DI2(distgrid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetI4(distgrid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DI4(distgrid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetI8(distgrid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DI8(distgrid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetR4(distgrid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DR4(distgrid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetR8(distgrid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSet1DR8(distgrid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetLgcl(distgrid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetLgclList(distgrid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(distgrid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetChar(distgrid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="distgrid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetChar(distgrid, name, value, & 
 ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetChar(distgrid, name, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_DistGridAttSetCharList(distgrid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_DistGrid), intent(inout) :: distgrid 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [distgrid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="distgrid" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_DistGridGetInit,distgrid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(distgrid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_DistGridAttSetCharList 

!-------------------------------------------------------------------------
! FIELD
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStandard" 
 
!BOPI 
! !IROUTINE: AttAddPackStandard - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldAttAddPackStd(field, convention, purpose, & 
 nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: attpacknest 
 character (len=*), parameter :: object="field" 
 
 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (convention .ne. "ESMF" .or. purpose .ne. "General") then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "Convention must be ESMF, and purpose must be General for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE; 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateStandard(field%ftypep%base, convention, & 
 purpose, object, localrc) 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & 
 "cannot nest an ESMF standard Attribute package onto a custom package", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstm" 
!BOPI 
! !IROUTINE: AttAddPackCstm - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldAttAddPackCstm(field, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an 
! existing Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [count] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="field" 
 type(ESMF_Logical) :: attpacknest 

 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 if (localCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "attrList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateCustom(field%ftypep%base, convention, & 
 purpose, object, localrc) 
 else 
 call c_ESMC_AttPackNest(field%ftypep%base, convention, & 
 purpose, object, nestConvention, nestPurpose, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(field%ftypep%base, attrList(i), convention, & 
 purpose, object, localrc) 
 end do 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttAddPackCstm 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetI1(field, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DI1(field, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetI2(field, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DI2(field, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetI4(field, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DI4(field, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetI8(field, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DI8(field, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetR4(field, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DR4(field, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetR8(field, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGet1DR8(field, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetLgcl(field, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [defaultvalue] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: localvalue, present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetLgclList(field, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [defaultvalueList] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of values in the Attribute. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetChar(field, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [defaultvalue] 
! The character default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetChar(field%ftypep%base, name, value, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetChar(field%ftypep%base, name, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_FieldAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetCharList(field, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [defaultvalueList] 
! The character list default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The itemCount of the character items to retrieve 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: present_flag, attpack 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 do i=1,litemCount 
 lens(i) = len (valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(field%ftypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(field%ftypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetCount(field, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(field%ftypep%base, count, lattcountflag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetInfoByNam(field, name, typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character(len=*), intent(in) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 call c_ESMC_AttributeGetInfoName(field%ftypep%base, name, & 
 localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldAttGetInfoByNum(field, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character types, 
! this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 call c_ESMC_AttributeGetInfoNum(field%ftypep%base, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_FieldAttLinkGrid(field, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 type(ESMF_Grid), intent(inout) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 call c_ESMC_AttributeLink(& 
 field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttLinkGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_FieldAttLinkRmGrid(field, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 type(ESMF_Grid), intent(inout) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 field%ftypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttLinkRmGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_FieldAttRead(field, fileName, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len=*), intent(in), optional :: fileName 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt field}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item[{[fileName]}] 
! The file name to be read from. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, localrc 
 
 fileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS 
 !TODO: Remove the following dummy test when dummy argument actually used 
 if (convention == convention .and. purpose==purpose) continue 
 
 ! get length of given fileName for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 ! invoke C to C++ entry point 
 ! TODO: convention, purpose 
 call c_ESMC_AttributeRead(field%ftypep%base, fileNameLen, fileName, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_FieldAttRemove(field, name, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(field%ftypep%base, convention, & 
 purpose, fobject, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(field%ftypep%base, name, convention, & 
 purpose, fobject, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(field%ftypep%base, name, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetI1(field, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DI1(field, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetI2(field, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DI2(field, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetI4(field, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DI4(field, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetI8(field, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DI8(field, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetR4(field, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DR4(field, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetR8(field, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSet1DR8(field, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetLgcl(field, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetLgclList(field, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(field%ftypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetChar(field, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetChar(field%ftypep%base, name, value, & 
 ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetChar(field%ftypep%base, name, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldAttSetCharList(field, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="field" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(field%ftypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_FieldAttUpdate(field, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [field] 
! An {\tt ESMF_Field} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(field%ftypep%base, vm, rootList, count, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_FieldAttWrite(field, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_Field), intent(inout) :: field 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="field" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(field%ftypep%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(field%ftypep%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldAttWrite 

!-------------------------------------------------------------------------
! FIELDBUNDLE
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstm" 
!BOPI 
! !IROUTINE: AttAddPackCstm - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_FieldBundleAttAddPackCstm(fieldbundle, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an 
! existing Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [count] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="fieldbundle" 
 type(ESMF_Logical) :: attpacknest 

 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 if (localCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "attrList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateCustom(fieldbundle%btypep%base, convention, & 
 purpose, object, localrc) 
 else 
 call c_ESMC_AttPackNest(fieldbundle%btypep%base, convention, & 
 purpose, object, nestConvention, nestPurpose, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(fieldbundle%btypep%base, attrList(i), convention, & 
 purpose, object, localrc) 
 end do 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttAddPackCstm 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetI1(fieldbundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DI1(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetI2(fieldbundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DI2(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetI4(fieldbundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DI4(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetI8(fieldbundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DI8(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetR4(fieldbundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DR4(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetR8(fieldbundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGet1DR8(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetLgcl(fieldbundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [defaultvalue] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: localvalue, present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetLgclList(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [defaultvalueList] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of values in the Attribute. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetChar(fieldbundle, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [defaultvalue] 
! The character default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetChar(fieldbundle%btypep%base, name, value, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetChar(fieldbundle%btypep%base, name, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_FieldBundleAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetCharList(fieldbundle, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [defaultvalueList] 
! The character list default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The itemCount of the character items to retrieve 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: present_flag, attpack 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 do i=1,litemCount 
 lens(i) = len (valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(fieldbundle%btypep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(fieldbundle%btypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(fieldbundle%btypep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(fieldbundle%btypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetCount(fieldbundle, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(fieldbundle%btypep%base, count, lattcountflag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetInfoByNam(fieldbundle, name, typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character(len=*), intent(in) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 call c_ESMC_AttributeGetInfoName(fieldbundle%btypep%base, name, & 
 localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_FieldBundleAttGetInfoByNum(fieldbundle, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character types, 
! this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 call c_ESMC_AttributeGetInfoNum(fieldbundle%btypep%base, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_FieldBundleAttLinkField(fieldbundle, field, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_Field), intent(inout) :: field 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [field] 
! An {\tt ESMF_Field} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 call c_ESMC_AttributeLink(& 
 fieldbundle%btypep%base, field%ftypep%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkField 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_FieldBundleAttLinkGrid(fieldbundle, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_Grid), intent(inout) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 call c_ESMC_AttributeLink(& 
 fieldbundle%btypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_FieldBundleAttLinkRmField(fieldbundle, field, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_Field), intent(inout) :: field 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [field] 
! An {\tt ESMF_Field} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 fieldbundle%btypep%base, field%ftypep%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkRmField 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_FieldBundleAttLinkRmGrid(fieldbundle, grid, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_Grid), intent(inout) :: grid 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 fieldbundle%btypep%base, grid, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttLinkRmGrid 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_FieldBundleAttRead(fieldbundle, fileName, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len=*), intent(in), optional :: fileName 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt fieldbundle}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item[{[fileName]}] 
! The file name to be read from. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, localrc 
 
 fileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS 
 !TODO: Remove the following dummy test when dummy argument actually used 
 if (convention == convention .and. purpose==purpose) continue 
 
 ! get length of given fileName for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 ! invoke C to C++ entry point 
 ! TODO: convention, purpose 
 call c_ESMC_AttributeRead(fieldbundle%btypep%base, fileNameLen, fileName, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_FieldBundleAttRemove(fieldbundle, name, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(fieldbundle%btypep%base, convention, & 
 purpose, fobject, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(fieldbundle%btypep%base, name, convention, & 
 purpose, fobject, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(fieldbundle%btypep%base, name, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetI1(fieldbundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DI1(fieldbundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetI2(fieldbundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DI2(fieldbundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetI4(fieldbundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DI4(fieldbundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetI8(fieldbundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DI8(fieldbundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetR4(fieldbundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DR4(fieldbundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetR8(fieldbundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSet1DR8(fieldbundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetLgcl(fieldbundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetLgclList(fieldbundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(fieldbundle%btypep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetChar(fieldbundle, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetChar(fieldbundle%btypep%base, name, value, & 
 ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetChar(fieldbundle%btypep%base, name, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_FieldBundleAttSetCharList(fieldbundle, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="fieldbundle" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(fieldbundle%btypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(fieldbundle%btypep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_FieldBundleAttUpdate(fieldbundle, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(fieldbundle%btypep%base, vm, rootList, count, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_FieldBundleAttWrite(fieldbundle, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="fieldbundle" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(fieldbundle%btypep%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(fieldbundle%btypep%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_FieldBundleAttWrite 

!-------------------------------------------------------------------------
! GRID
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStandard" 
 
!BOPI 
! !IROUTINE: AttAddPackStandard - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridAttAddPackStd(grid, convention, purpose, & 
 nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: attpacknest 
 character (len=*), parameter :: object="grid" 
 
 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (convention .ne. "ESMF" .or. purpose .ne. "General") then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "Convention must be ESMF, and purpose must be General for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE; 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateStandard(grid, convention, & 
 purpose, object, localrc) 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & 
 "cannot nest an ESMF standard Attribute package onto a custom package", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstm" 
!BOPI 
! !IROUTINE: AttAddPackCstm - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_GridAttAddPackCstm(grid, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an 
! existing Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [count] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="grid" 
 type(ESMF_Logical) :: attpacknest 

 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 if (localCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "attrList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateCustom(grid, convention, & 
 purpose, object, localrc) 
 else 
 call c_ESMC_AttPackNest(grid, convention, & 
 purpose, object, nestConvention, nestPurpose, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(grid, attrList(i), convention, & 
 purpose, object, localrc) 
 end do 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttAddPackCstm 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetI1(grid, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DI1(grid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetI2(grid, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DI2(grid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetI4(grid, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DI4(grid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetI8(grid, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DI8(grid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetR4(grid, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DR4(grid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetR8(grid, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGet1DR8(grid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetLgcl(grid, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [defaultvalue] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: localvalue, present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetLgclList(grid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [defaultvalueList] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of values in the Attribute. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetChar(grid, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [defaultvalue] 
! The character default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetChar(grid, name, value, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetChar(grid, name, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_GridAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetCharList(grid, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [defaultvalueList] 
! The character list default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The itemCount of the character items to retrieve 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: present_flag, attpack 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 do i=1,litemCount 
 lens(i) = len (valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(grid, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(grid, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetCount(grid, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(grid, count, lattcountflag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetInfoByNam(grid, name, typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character(len=*), intent(in) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 call c_ESMC_AttributeGetInfoName(grid, name, & 
 localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_GridAttGetInfoByNum(grid, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character types, 
! this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 call c_ESMC_AttributeGetInfoNum(grid, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_GridAttRead(grid, fileName, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len=*), intent(in), optional :: fileName 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt grid}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An {\tt ESMF_Grid} object. 
! \item[{[fileName]}] 
! The file name to be read from. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, localrc 
 
 fileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS 
 !TODO: Remove the following dummy test when dummy argument actually used 
 if (convention == convention .and. purpose==purpose) continue 
 
 ! get length of given fileName for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 ! invoke C to C++ entry point 
 ! TODO: convention, purpose 
 call c_ESMC_AttributeRead(grid, fileNameLen, fileName, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttRead 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_GridAttRemove(grid, name, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(grid, convention, & 
 purpose, fobject, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(grid, name, convention, & 
 purpose, fobject, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(grid, name, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttRemove 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetI1(grid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DI1(grid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetI2(grid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DI2(grid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetI4(grid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DI4(grid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetI8(grid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DI8(grid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetR4(grid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DR4(grid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetR8(grid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSet1DR8(grid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetLgcl(grid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetLgclList(grid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(grid, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetChar(grid, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="grid" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetChar(grid, name, value, & 
 ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetChar(grid, name, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_GridAttSetCharList(grid, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_Grid), intent(inout) :: grid 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [grid] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="grid" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(grid, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_GridAttSetCharList 

!-------------------------------------------------------------------------
! STATE
!-------------------------------------------------------------------------
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackStandard" 
 
!BOPI 
! !IROUTINE: AttAddPackStandard - Add an ESMF standard Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_StateAttAddPackStd(state, convention, purpose, & 
 nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add an ESMF standard Attribute package 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: attpacknest 
 character (len=*), parameter :: object="state" 
 
 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (convention .ne. "ESMF" .or. purpose .ne. "General") then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_WRONG, & 
 "Convention must be ESMF, and purpose must be General for ESMF standard Attribute packages", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE; 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateStandard(state%statep%base, convention, & 
 purpose, object, localrc) 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_OBJ_BAD, & 
 "cannot nest an ESMF standard Attribute package onto a custom package", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttAddPackStd
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttAddPackCstm" 
!BOPI 
! !IROUTINE: AttAddPackCstm - Add a custom Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeAdd() 
 subroutine ESMF_StateAttAddPackCstm(state, convention, purpose, & 
 attrList, count, nestConvention, nestPurpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: convention 
 character (len = *), intent(in) :: purpose 
 character (len = *), dimension(:), intent(in) :: attrList 
 integer, intent(in), optional :: count 
 character (len = *), intent(in), optional :: nestConvention 
 character (len = *), intent(in), optional :: nestPurpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Add a custom Attribute package for the object, or modify an 
! existing Attribute package. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [convention] 
! The convention of the new Attribute package. 
! \item [purpose] 
! The purpose of the new Attribute package. 
! \item [attrList] 
! An array of character strings specifying the names of the user defined Attributes 
! \item [count] 
! The count of the number of Attributes to add to the package 
! \item [nestConvention] 
! The convention of the Attribute package around which to nest the 
! new Attribute package. 
! \item [nestPurpose] 
! The purpose of the Attribute package around which to nest the 
! new Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, localCount 
 character(len=*), parameter :: object="state" 
 type(ESMF_Logical) :: attpacknest 

 ! Initialize return code; assume failure until success is certain 
 attpacknest = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(count)) then 
 if (count > size(attrList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_SIZE, & 
 "count cannot be larger than size(attrList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 localCount = count 
 else 
 localCount = size(attrList) 
 end if 
 
 if (localCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "attrList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(nestConvention).or.present(nestPurpose)) then 
 if (present(nestConvention).and..not.present(nestPurpose).or. & 
 present(nestPurpose).and..not.present(nestConvention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both nestConvention and nestPurpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 else 
 attpacknest = ESMF_TRUE 
 endif 
 endif 
 
 if (attpacknest == ESMF_FALSE) then 
 call c_ESMC_AttPackCreateCustom(state%statep%base, convention, & 
 purpose, object, localrc) 
 else 
 call c_ESMC_AttPackNest(state%statep%base, convention, & 
 purpose, object, nestConvention, nestPurpose, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 do i = 1, localCount 
 call c_ESMC_AttPackAddAttribute(state%statep%base, attrList(i), convention, & 
 purpose, object, localrc) 
 end do 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttAddPackCstm 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttributeCopy" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy between objects 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeCopy() 
 subroutine ESMF_StateAttCopy(state1, state2, attcopyflag, atttreeflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state1 
 type(ESMF_State), intent(inout) :: state2 
 type(ESMF_AttCopyFlag), intent(in) :: attcopyflag 
 type(ESMF_AttTreeFlag), intent(in) :: atttreeflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Copy all Attributes in one hierarchy to another. 
! 
! The arguments are: 
! \begin{description} 
! \item [state1] 
! An {\tt ESMF_State} object. 
! \item [state2] 
! An {\tt ESMF_State} object. 
! \item [attcopyflag] 
! A flag to determine if the copy is to be by reference, value, or both 
! \item [atttreeflag] 
! A flag to determine if the copy is supposed to descend the Attribute 
! hierarchy 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state1,rc) 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state2,rc) 
 
 call c_ESMC_AttributeCopy(state1%statep%base, state2%statep%base, & 
 attcopyflag, atttreeflag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttCopy 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetI1(state, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(out) :: value 
 integer(ESMF_KIND_I1), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DI1(state, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I1), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetI2(state, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(out) :: value 
 integer(ESMF_KIND_I2), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DI2(state, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I2), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetI4(state, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(out) :: value 
 integer(ESMF_KIND_I4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DI4(state, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetI8(state, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(out) :: value 
 integer(ESMF_KIND_I8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DI8(state, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList 
 integer(ESMF_KIND_I8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetR4(state, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(out) :: value 
 real(ESMF_KIND_R4), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DR4(state, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R4), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetR8(state, name, value, defaultvalue, & 
 convention, purpose, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(out) :: value 
 real(ESMF_KIND_R8), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 endif 
 else 
 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGet1DR8(state, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList 
 real(ESMF_KIND_R8), dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns an Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The real value of the named Attribute. 
! \item [defaultvalue] 
! The real default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetLgcl(state, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 logical, intent(out) :: value 
 logical, intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical Attribute from the {\tt array}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The logical value of the named Attribute. 
! \item [defaultvalue] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: localvalue, present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 value = localvalue 
 endif 
 endif 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetLgclList(state, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in) :: name 
 logical, dimension(:), intent(out) :: valueList 
 logical, dimension(:), intent(inout), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a logical list Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The logical values of the named Attribute. 
! \item [defaultvalueList] 
! The logical default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of values in the Attribute. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount, i 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 

 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetChar" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetChar(state, name, value, defaultvalue, & 
 convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 character (len = *), intent(out) :: value 
 character (len = *), intent(inout), optional :: defaultvalue 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [value] 
! The character value of the named Attribute. 
! \item [defaultvalue] 
! The character default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetChar(state%statep%base, name, value, & 
 convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetChar(state%statep%base, name, value, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalue)) then 
 value = defaultvalue 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 endif 
 
 if (present(rc)) rc = localrc 
 
 end subroutine ESMF_StateAttGetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCharList" 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetCharList(state, name, valueList, & 
 defaultvalueList, convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 character (len=*), dimension(:), intent(out) :: valueList 
 character (len=*), dimension(:), intent(in), optional :: defaultvalueList 
 character (len=*), intent(in), optional :: convention 
 character (len=*), intent(in), optional :: purpose 
 integer, intent(inout), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns a character Attribute from the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to retrieve. 
! \item [valueList] 
! The character list values of the named Attribute. 
! \item [defaultvalueList] 
! The character list default value of the named Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The itemCount of the character items to retrieve 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: present_flag, attpack 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 present_flag = ESMF_FALSE 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 do i=1,litemCount 
 lens(i) = len (valueList) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackIsPresent(state%statep%base, name, convention, purpose, & 
 fobject, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttPackGetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, convention, purpose, fobject, localrc) 
 end if 
 else 
 call c_ESMC_AttributeIsPresent(state%statep%base, name, present_flag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 if (present_flag == ESMF_TRUE) then 
 call c_ESMC_AttributeGetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, lens, valueString, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if(present_flag .ne. ESMF_TRUE) then 
 if(present(defaultvalueList)) then 
 if(size(valueList) .lt. size(defaultvalueList)) then 
 do i=1,size(valueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 else 
 do i=1,size(defaultvalueList) 
 valueList(i) = defaultvalueList(i) 
 enddo 
 endif 
 else 
 call ESMF_LogMsgSetError(ESMF_RC_ATTR_NOTSET, & 
 "Attribute not found, and no default given", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 else 
 
 j = 1 
 do i=1,litemCount 
 valueList(i) = valueString(j:(j+lens(i)-1)) 
 j = j + lens(i) 
 enddo 
 
 if (present(itemCount)) then 
 itemCount = litemCount 
 endif 
 
 endif 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetCount" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetCount(state, count, attcountflag, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 integer, intent(out) :: count 
 type(ESMF_AttGetCountFlag), intent(in), optional :: attcountflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns the number of Attributes associated with the given object 
! in the argument {\tt count}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [count] 
! The number of Attributes associated with this object. 
! \item [attcountflag] 
! Flag to determine which Attribute count to return. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_AttGetCountFlag) :: lattcountflag 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(attcountflag)) then 
 lattcountflag = attcountflag 
 else 
 lattcountflag = ESMF_ATTGETCOUNT_ATTRIBUTE 
 endif 
 
 call c_ESMC_AttributeGetCount(state%statep%base, count, lattcountflag, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetCount 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNam" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by name 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetInfoByNam(state, name, typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character(len=*), intent(in) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the named Attribute, 
! including {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to query. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! The number of items in this Attribute. For character types, 
! the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 call c_ESMC_AttributeGetInfoName(state%statep%base, name, & 
 localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetInfoByNam 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttGetInfoByNum" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by index number 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeGet() 
 subroutine ESMF_StateAttGetInfoByNum(state, attributeIndex, name, & 
 typekind, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 integer, intent(in) :: attributeIndex 
 character(len=*), intent(out) :: name 
 type(ESMF_TypeKind), intent(out), optional :: typekind 
 integer, intent(out), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Returns information associated with the indexed Attribute, 
! including {\tt name}, {\tt typekind} and {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [attributeIndex] 
! The index number of the Attribute to query. 
! \item [name] 
! Returns the name of the Attribute. 
! \item [{[typekind]}] 
! The typekind of the Attribute. 
! \item [{[itemCount]}] 
! Returns the number of items in this Attribute. For character types, 
! this is the length of the character string. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=len(name)) :: localName 
 type(ESMF_TypeKind) :: localTk 
 integer :: litemCount 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 call c_ESMC_AttributeGetInfoNum(state%statep%base, attributeIndex, & 
 localName, localTk, litemCount, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 name = localName 
 if (present(typekind)) typekind = localTk 
 if (present(itemCount)) itemCount = litemCount 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttGetInfoByNum 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkArray(state, array, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_Array), intent(inout) :: array 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [array] 
! An {\tt ESMF_Array} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "array" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 call c_ESMC_AttributeLink(state%statep%base, & 
 array, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state%statep%st == ESMF_STATE_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state%statep%st == ESMF_STATE_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkArray 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkArrayBundle(state, arraybundle, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "array" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 call c_ESMC_AttributeLink(state%statep%base, & 
 arraybundle, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state%statep%st == ESMF_STATE_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state%statep%st == ESMF_STATE_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkArrayBundle 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkField(state, field, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_Field), intent(inout) :: field 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [field] 
! An {\tt ESMF_Field} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "field" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 call c_ESMC_AttributeLink(state%statep%base, & 
 field%ftypep%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state%statep%st == ESMF_STATE_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state%statep%st == ESMF_STATE_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkField 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkFieldBundle(state, fieldbundle, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "field" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 call c_ESMC_AttributeLink(state%statep%base, & 
 fieldbundle%btypep%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state%statep%st == ESMF_STATE_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state%statep%st == ESMF_STATE_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkFieldBundle 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_StateAttLink" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLink - Link one Attribute hierarchy to another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLink() 
 subroutine ESMF_StateAttLinkState(state1, state2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state1 
 type(ESMF_State), intent(inout) :: state2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state1] 
! An {\tt ESMF\_State} object. 
! \item [state2] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 type(ESMF_Logical) :: lvalue1, lvalue2 
 character (len=*), parameter :: lobject = "field" 
 character (len=*), parameter :: lname1 = 'import' 
 character (len=*), parameter :: lname2 = 'export' 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state1,rc) 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state2,rc) 
 
 call c_ESMC_AttributeLink(state1%statep%base, & 
 state2%statep%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 ! set the import and export Attributes on any Field connected to this State 
 lvalue1 = .true. 
 lvalue2 = .false. 
 if (state1%statep%st == ESMF_STATE_IMPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 else if (state1%statep%st == ESMF_STATE_EXPORT) then 
 call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname1, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname2, & 
 ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmArray(state, array, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_Array), intent(inout) :: array 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [array] 
! An {\tt ESMF_Array} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 state%statep%base, array, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmArray 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmArrayBundle(state, arraybundle, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_ArrayBundle), intent(inout) :: arraybundle 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [arraybundle] 
! An {\tt ESMF_ArrayBundle} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundle,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 state%statep%base, arraybundle, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmArrayBundle 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmField(state, field, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_Field), intent(inout) :: field 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [field] 
! An {\tt ESMF_Field} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 state%statep%base, field%ftypep%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmField 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmFieldBundle(state, fieldbundle, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_FieldBundle), intent(inout) :: fieldbundle 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [fieldbundle] 
! An {\tt ESMF_FieldBundle} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 state%statep%base, fieldbundle%btypep%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmFieldBundle 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttLinkRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeLinkRemove - Unlink one Attribute hierarchy from another 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeLinkRemove() 
 subroutine ESMF_StateAttLinkRmState(state1, state2, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state1 
 type(ESMF_State), intent(inout) :: state2 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Unattaches two Attribute hierarchies 
! 
! The arguments are: 
! \begin{description} 
! \item [state1] 
! An {\tt ESMF_State} object. 
! \item [state2] 
! An {\tt ESMF_State} object. 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state1,rc) 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state2,rc) 
 
 call c_ESMC_AttributeLinkRemove(& 
 state1%statep%base, state2%statep%base, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttLinkRmState 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRemove" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute Package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRemove() 
 subroutine ESMF_StateAttRemove(state, name, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in), optional :: name 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
! 
! !DESCRIPTION: 
! Removes an Attribute on the object. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to destroy. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE .and. .not.present(name)) then 
 call c_ESMC_AttPackRemove(state%statep%base, convention, & 
 purpose, fobject, localrc) 
 else if (attpack == ESMF_TRUE .and. present(name)) then 
 call c_ESMC_AttPackRemoveAttribute(state%statep%base, name, convention, & 
 purpose, fobject, localrc) 
 else if (present(name)) then 
 call c_ESMC_AttributeRemove(state%statep%base, name, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttRemove 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttRead" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeRead - Read an Attribute package 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeRead() 
 subroutine ESMF_StateAttRead(state, fileName, convention, purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len=*), intent(in), optional :: fileName 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Read the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item[{[fileName]}] 
! The file name to be read from. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 ! initialize fileName length to zero for non-existent name 
 integer :: fileNameLen, localrc 
 
 fileNameLen = 0 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 localrc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 !DUMMY TEST TO QUIET DOWN COMPILER WARNINGS 
 !TODO: Remove the following dummy test when dummy argument actually used 
 if (convention == convention .and. purpose==purpose) continue 
 
 ! get length of given fileName for C++ validation 
 if (present(fileName)) then 
 fileNameLen = len_trim(fileName) 
 end if 
 
 ! invoke C to C++ entry point 
 ! TODO: convention, purpose 
 call c_ESMC_AttributeRead(state%statep%base, fileNameLen, fileName, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttRead 

!------------------------------------------------------------------------------ 
! <This section created by macro - do not edit directly> 
 
!! < start of macros which become actual subroutine bodies after expansion > 
 
!BOPI 
!EOPI 
 
#ifndef ESMF_NO_INTEGER_1_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetI1(state, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetI1 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DI1(state, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I1), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I1, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DI1 
 
#endif 
#ifndef ESMF_NO_INTEGER_2_BYTE 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetI2(state, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetI2 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DI2(state, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I2), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I2, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DI2 
 
#endif 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetI4(state, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetI4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DI4(state, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DI4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetI8(state, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetI8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DI8(state, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_I8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DI8 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetR4(state, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetR4 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DR4(state, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R4, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DR4 
 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetR8(state, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The integer value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, 1, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetR8 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSet1D" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set an Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSet1DR8(state, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach an Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of integer items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [valueList] 
! The integer values of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of integers in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 

 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_R8, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSet1DR8 
 
 
! < end macro - do not edit directly > 
!------------------------------------------------------------------------------ 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgcl" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetLgcl(state, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 logical, intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: localvalue 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 localvalue = value 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetLgcl 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetLgclList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetLgclList(state, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 logical, dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a logical list Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt valueList}. 
! The number of logical items in the {\tt valueList} is 
! given by {\tt itemCount}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The logical true/false values of the Attribute. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [itemCount] 
! The number of logicals in the {\tt valueList}. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, litemCount 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, & 
 convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetValue(state%statep%base, name, & 
 ESMF_TYPEKIND_LOGICAL, litemCount, valueList, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetLgclList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetChar" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetChar(state, name, value, convention, & 
 purpose, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in) :: name 
 character (len = *), intent(in) :: value 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetChar(state%statep%base, name, value, & 
 ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetChar(state%statep%base, name, value, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetChar 
 
!------------------------------------------------------------------------------ 
#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttSetCharList" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeSet() 
 subroutine ESMF_StateAttSetCharList(state, name, valueList, & 
 convention, purpose, itemCount, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character(len=*), intent(in) :: name 
 character (len = *), dimension(:), intent(in) :: valueList 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 integer, intent(in), optional :: itemCount 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Attach a character Attribute to the object. 
! The Attribute has a {\tt name} and a {\tt value}. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An ESMF object. 
! \item [name] 
! The name of the Attribute to add. 
! \item [value] 
! The character value of the Attribute to add. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, i, j, litemCount 
 character(len=*), parameter :: fobject="state" 
 integer, dimension(size(valueList)) :: lens 
 character(len=(size(valueList)*len(valueList))) :: valueString 
 type(ESMF_Logical) :: attpack 

 ! Initialize 
 localrc = ESMF_RC_NOT_IMPL 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(itemCount)) then 
 if (itemCount > size(valueList)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "itemCount cannot be larger than size(valueList)", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 litemCount = itemCount 
 else 
 litemCount = size(valueList) 
 end if 
 
 if (litemCount .le. 0) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_BAD, & 
 "valueList is too small", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 
 j = 1 
 do i=1,litemCount 
 lens(i) = len_trim(valueList(i)) 
 valueString(j:(j+lens(i)-1)) = valueList(i) 
 j = j + lens(i) 
 enddo 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 call c_ESMC_AttPackSetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, convention, purpose, fobject, localrc) 
 else 
 call c_ESMC_AttributeSetCharList(state%statep%base, name, ESMF_TYPEKIND_CHARACTER, & 
 litemCount, valueString, lens, localrc) 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttSetCharList 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttUpdate" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy 
! 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeUpdate() 
 subroutine ESMF_StateAttUpdate(state, vm, rootList, rc) 
! 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 type(ESMF_VM), intent(in) :: vm 
 integer, dimension(:), intent(in) :: rootList 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Update an Attribute hierarchy. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF_State} object. 
! \item [vm] 
! The virtural machine over which this Attribute hierarchy 
! should be updated. 
! \item [rootList] 
! The list of "root" PETs that are to be used to update. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc, count ! Error status 
 
 ! Initialize return code; assume failure until success is certain 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 count = size(rootList) 
 call c_ESMC_AttributeUpdate(state%statep%base, vm, rootList, count, localrc) 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttUpdate 

#undef ESMF_METHOD 
#define ESMF_METHOD "ESMF_AttWrite" 
 
!BOPI 
! !IROUTINE: ESMF_AttributeWrite - Write an Attribute package to file 
 
! !INTERFACE: 
 ! Private name; call using ESMF_AttributeWrite() 
 subroutine ESMF_StateAttWrite(state, convention, purpose, attwriteflag, rc) 
 
! !ARGUMENTS: 
 type(ESMF_State), intent(inout) :: state 
 character (len = *), intent(in), optional :: convention 
 character (len = *), intent(in), optional :: purpose 
 type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag 
 integer, intent(out), optional :: rc 
 
! 
! !DESCRIPTION: 
! Write the Attribute package for the {\tt state}. 
! The Attribute package defines the convention, purpose, and object type 
! of the associated Attributes. 
! 
! The arguments are: 
! \begin{description} 
! \item [state] 
! An {\tt ESMF\_State} object. 
! \item [convention] 
! The convention of the Attribute package. 
! \item [purpose] 
! The purpose of the Attribute package. 
! \item [attwriteflag] 
! Flag to determine the format for writing the Attributes. 
! \item [{[rc]}] 
! Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. 
! \end{description} 
! 
! 
!EOPI 
 
 integer :: localrc 
 character(len=*), parameter :: fobject="state" 
 character(len=*), parameter :: ftarobj="field" 
 type(ESMF_AttWriteFlag) :: writeflag 
 type(ESMF_Logical) :: attpack 
 
 ! Initialize return code; assume failure until success is certain 
 attpack = ESMF_FALSE 
 if (present(rc)) rc = ESMF_RC_NOT_IMPL 
 
 ! check input variables 
 ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) 
 
 if (present(convention).or.present(purpose)) then 
 if (present(convention).and..not.present(purpose).or. & 
 present(purpose).and..not.present(convention)) then 
 call ESMF_LogMsgSetError(ESMF_RC_ARG_INCOMP, & 
 "both convention and purpose must be present or not", & 
 ESMF_CONTEXT, rc) 
 return 
 endif 
 attpack = ESMF_TRUE 
 endif 
 
 if (present(attwriteflag)) then 
 writeflag = attwriteflag 
 else 
 writeflag = ESMF_ATTWRITE_TAB 
 endif 
 
 if (attpack == ESMF_TRUE) then 
 if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then 
 call c_ESMC_AttributeWriteTab(state%statep%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then 
 call c_ESMC_AttributeWriteXML(state%statep%base, convention, & 
 purpose, fobject, ftarobj, localrc) 
 endif 
 endif 
 if (ESMF_LogMsgFoundError(localrc, ESMF_ERR_PASSTHRU, & 
 ESMF_CONTEXT, rcToReturn=rc)) return 
 
 if (present(rc)) rc = ESMF_SUCCESS 
 
 end subroutine ESMF_StateAttWrite 

!------------------------------------------------------------------------------
end module ESMF_AttributeMod
